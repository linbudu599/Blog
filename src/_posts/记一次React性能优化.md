---
category: Record
tags:
  - React
  - Optimization
date: 2020-7-004
title: 记一次 React 性能优化
---

## 使用到的手段

- immer
- useMemo
- useEffect
- useCallback

## 前言

由于项目涉密，然后我又懒得再开个 SandBox 写 Demo 了（呜呜呜以后有机会补上好吧），因此这篇文章可能就干巴巴的，我尽量讲的通俗易懂一些。不过这里也没有讲什么高深的内容~，相信我，你读一遍就觉得”这么简单你还写篇文章？“

有一说一，React 和 Vue 的最大区别就是优化手段吧，Vue 都帮你处理好了性能优化啥的，而 React 组件就需要自己吭哧吭哧的去使用各种手段，memo，缓存，更新控制，不可变数据...

## useEffect

作为最常使用的两个 Hooks 之一（`useState`和`useEffect`用的最多没意见 8！），我其实一直在见到`useEffect`的错误用法（当然，最开始我也是瞎用的），在经历了`Maxium callback size...` / Duang Duang Duang 的诡异重渲染 / 无响应之后，我想大部分人都会痛定思痛，好好思考下，到底怎么用，什么时候用它。

使用`useEffect`意味着 React 组件会在 DOM 渲染完毕/更新后执行某些操作（默认情况下），也就是 Class 组件的 DidMount 与 DidUpdte，React 会保证！每次运行时 Effect(即我们传递的函数)都已经执行完毕。React 会保存 effect，并在更新完 DOM 后执行它。

通常情况下 effect 不会有太诡异的用法，但第二个参数`depsArray`则是花样百出:

```tsx
useEffect(() => {
  fetch(`/${id}`);
}, [id]);
useEffect(() => {
  fetch();
}, []);
useEffect(() => {
  fetch();
});
```

以上就是常见的几种情况，你应该很清楚他们分别代表着什么场景，我这里只做简单的讲解。

传入空的依赖数组`[]`时，useEffect 相当于 DidMount，只会在挂载时执行一次，而不传依赖数组则会使得 effect 每次重渲染都被执行。

注意这里可能存在的误区，useEffect 并不必然导致重渲染，相反它在每次更新后才被调用，同时根据依赖数组决定是否调用再次调用 effect，很简单的一个道理但我之前写了几个月才意识到...。决定组件更新的 hooks 实际上是`useMemo`（没想到吧！那你一定跟我一样没认真看过官方文档）

所以我们该如何使用`useEffect`进行优化已经很明白了，根据 effect 如实的使用依赖数组，避免不必要的副作用调用。

## useCallback

```tsx
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

`useCallback`其实也是一个挺好用的 hooks，它返回经过缓存的回调函数，类似`useEffect`，它也有依赖数组，并且也只会在依赖数组变动时更新回调函数。在我这次的场景里，主要是用于缓存内部有较复杂开销调用 actions（使用了 icestore 作为状态管理方案，强推！）的函数。这个 hook 主要避免了函数式组件每次执行都会重新创建函数的不必要开销。

## useMemo

```tsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
// ...

<>
  {useMemo(
    () => (
      <Wuhu props={config} />
    ),
    [config]
  )}
</>;
```

这是本次性能优化起到最大作用的选手，我主要使用的上面代码的用法，使用它来缓存组件（从这一点来看似乎有点像之前的 memo）。

顺便提一嘴 memo，实际上它并不是 hook（名字就看得出来 ⑧），你可以把它等价于只比较`props`的`PureComponent`，同样使用`shallowEuqal`方法比较。

组件结构类似这样：

**P**

- **C1**
- **C2**
- **C3**

`C1`更新时，C2 C3 也会被强制重渲染（有使用了基于 context 的方案的原因），尤其是`C1`里主要是表单项，当每次输入时都会触发一次全局重渲染，数据和组件不复杂还好，复杂了真的输入时都会卡成 PPT。因此，对于并不依赖的三个子组件，完全可以分别使用`useMemo`包裹（我这里场景是 P 取回数据分发给三个子组件），来阻止不必要的重渲染。说到这里你应该会很熟悉...，是的，是不是很像`shouldComponentUpdate`？

`useMemo`和`useEffect`有一个很重要的不同，所以不要觉得它们作用是相似的。`useMemo`做的是在渲染前控制组件更新，如果依赖数组未检测变动那么它就不会更新。而`useEffect`做的是在渲染后，也就是 DOM 挂载/更新后去判断是否执行 effect，可以使用`useMemo`细粒度的控制组件的更新。但是在`useMemo`中不要去执行与渲染无关的操作，尤其是副作用！如果在这里操作数据，可能会喜提死循环~，毕竟记得，`useMemo`是在渲染中执行的。

## 分析性能问题

- 强大的 React DevTools，常用功能之一是在组件更新时高亮组件（`Hightlight Updates`），你可以检测是否有组件导致了全局页面的重渲染，或是两个不相关的组件是否互相影响了渲染。同时，当你想更细的找出是哪个组件哪个操作导致了过大的/不必要的开销，也可以使用它提供的`Profiler`（记录器），这个功能比较多，你可以自己摸索。我这里提供一个思路，开始记录后，执行一次操作，分析其中警示的渲染时间过长的应用，进行优化，再次执行相同的操作，观察效果~，以我的本次优化为例，同样操作的渲染时间由 800ms 下降到了 150ms。
- Chrome Perfomance，同样是一个很有用的工具，但本次没用到，就不赘述了。

## 一些误区

- 不要函数和组件都去包一遍，因为有时这么做不仅不会起到性能优化的作用，反而还会影响性能，毕竟缓存本身也是会占内存的哇。useMemo 本身就有开销，它要缓存一些值，后续渲染到被包裹的组件时还需要比较依赖数组决定返回啥...，最好只有在存在开销大的操作时才去使用。
- useCallback 不仅能够缓存函数, 还可以确保在依赖变化时拿到的必然是最新的函数(似乎这一点才是这个 API 的设计考量? 不然直接把函数定义在组件外面不就行了?)

## Immer

不妨比较下`Immutable.JS`与`ImmerJs`, 虽然二者都代表着不可变数据的思想,但我觉得其实本质上是两个东西.

Immer 思路主要是基于 ES6 的 Proxy(同样支持`defineProperty`作为 fallback), 当改变数据时以尽可能小的开销共享结构. Immer 将被操作对象的最初状态存储为`currentState`, 在修改状态时, 则会根据最初状态生成一个草稿状态`draftState`, 它是`currentState`的代理, 对`draftState`的修改会被记录下来用于生成最终状态`nextState`. Immer 在这个过程中共享了未修改的结构, 从而使得无需生成一个船新版本的状态.

ImmutableJs 作为另一款方案, 号称"FaceBook 工程师历经三年的烧脑之作", 则是从另外一个方面出发, 它实现了自己的数据结构(这一点上就和 immer 有本质的不同, immer 是基于 JS 原生数据结构的), 并且它的操作结果需要通过`toJS()`才能转化为 JS 对象, 哦对了前面还要`fromJS()`, 但是的确 Immutable 的性能会更好一些.

关于不可变数据流方案我还是感觉挺有趣的, 简略瞄了一下 Immer 源码好像也不会很复杂, 感觉和 Mobx 一样都是小而美的东西(是的 Immer 就是 Mobx 作者做的, 大概在 18 年 release 了 1.0.0), 后面有时间的话还是会单独写一篇不可变数据流的~
