---
category: Learning
tags:
  - Browser
date: 2020-3-23
title: 浅析浏览器渲染过程
---

这是昨天面试中的一个问题, 但是当时我最多只能详细描述到栅格化, 对于小哥问的"内存中优化"这个问题更是一点头绪没有:-(, 正好之前看到过一些这方面的文章感觉挺有意思, 于是特意总结一篇.

## 浏览器架构

### 多进程

在了解浏览器渲染机制之前有必要弄清楚这个概念: **浏览器的架构**, 以`Chrome`为例, 它的每个窗口都是一个独立的进程, 多个进程的顶层存在浏览器进程(`Browser Process`)来协调浏览器的其它进程, 你可以大致理解为 Node 中 Cluster 模块的主从模式.

这么设计的利弊也是很明显的:

- 单个窗口"噢哟,崩溃了!"不会影响到其它窗口
- 充分利用现在 CPU 多核优势
- 消耗的内存与 CPU 资源更多, 但是 Chrome 的话在内存释放做的还是很好的.

我们通常将现代浏览器包含的进程划分为以下三种:

- 主进程, 全局唯一, 即浏览器引擎, 主要负责页面管理/书签/前进后退/资源下载等
- 渲染进程, 可以认为每次新开一个窗口就会新建一个渲染进程, 包括页面渲染/JS 执行(分别对应渲染引擎与 JS 引擎)
- GPU 进程, GPU 渲染, 全局唯一
- 插件进程, 每个插件会创建一个进程

### 渲染进程

> 对于相同的 Tab 页面, 我认为其不一定会被合并为一个, 但是这也触及到我的知识盲区了

那么一个窗口内又有哪些线程? 想象我们打开一个网页, 绘制, 发送请求, 交互事件...

- **GUI 线程**, 解析 HTML&CSS, 渲染树 blabla..., 这也是本篇文章的重点, 因此这里先一笔带过, 注意当页面进行重绘/回流时该线程就会工作.
- **JS 引擎**, 解析与执行 JS 代码
- **事件线程**, 控制 Event Loop, 归属于浏览器, 所以不同浏览器的实现可能不同
- **定时器线程**, 为什么会单独开一个定时器线程呢, 因为 JS 引擎是单线程的, 如果阻塞等待的话会影响请求准确性, 因此单独开一个线程计时与触发.
- **异步请求线程**(Ajax 请求等)

我们知道线程实际上可以理解为进程内部不同的执行代码, 因此它们也会遵守一定规则:

- 一个渲染引擎同时只有一个 JS 引擎在执行

- GUI 与 JS 线程**互斥**, 即 JS 引擎时 HTML/CSS 解析会被阻塞(或者说挂起, GUI 的更新会被保存起来等 JS 引擎搞定完了再执行, 而页面的更新操作也要等到 JS 引擎空闲了才会执行)

  > 实际上事件循环和渲染也是有关系的, 大致顺序是 宏任务 -> 微任务 -> UI 渲染, 即每轮事件循环执行结束之后进行

- JS 引擎不断处理事件线程推送到**事件队列**的任务

- 定时器与异步请求注册的事件回调由事件线程添加到**事件队列**中, "来活了!"

## 渲染工作

在被问到"从 URL 到页面呈现发生了什么"这个问题时, 浏览器的渲染部分你至少能回答出来以下部分:

- 解析 HTML 与 CSS, 分别构建 **DOM 树** 与 **CSSOM 树**
- 附着合成, 得到**布局树**
- 由布局树, 计算得到元素尺寸与位置
- 绘制页面, 将图层信息交给 **GPU 进程**, GPU 进行合成(Composite), 显示页面

你可能会觉得这些已经够了, 但实际上远远不够, 每个部分都可以也必须展开分析, 毕竟浏览器对于前端可是吃饭的家伙, 再熟悉也不为过. 接下来我会从这四个方面进行展开分析:-)

### 解析 HTML

DOM 就像是网页的骨架, 除了史莱姆以外骨架有多重要就不用说了吧, 它实际上也扮演着 **编程接口** 的角色, 比如我们动态替换页面元素等操作. 我们主要关注从 HTML 原始数据到解析为 DOM 树的过程:

[HTML5 Standard](https://html.spec.whatwg.org/multipage/parsing.html#parsing)中对解析过程进行了很详细的介绍, 主要分为 **Tokenizer** 与 **Tree Construction** 这两个阶段, 即 **令牌化** 与 **建树**.

如果更详细的话, 即是下面这张图的流程:

**字节 -> 字符 -> 令牌(标记) -> 建树 -> 成型 DOM 树**

![img](https://html.spec.whatwg.org/images/parsing-model-overview.svg)

#### 令牌化

规范中强调, 解析实现必须使用类似状态机的机制来令牌化 HTML, 举一个简单的例子

```html
<html>
  <head>
    Penumbra
  </head>
  <body>
    <p>
      Hello World!
    </p>
  </body>
</html>
```

- 首先遇到`<`符号, 此时切换状态为 **标记打开**
- 进入标记名称收集状态, `html`
- 遇到`>`, 切换为 **数据状态(Data State)**

- 对 `<body>` 与 `<p>` 如法炮制, 但是在 `<p>` 标签解析时, 会在数据状态下接收其中字符串
- 接收到 `</body>` 的 `<` 与 `/`, 进入 **标记打开** 与创建 **End Tag** 的 **Token**
- 进入标记名称状态(`body`), 遇到 `>` 再回到数据状态

经过以上处理会将原始 HTML 文档处理为标记信息(token), 然后发送给...建树器 ⬇

#### 建树

我们都知道`document`是 DOM 树的根节点, 它的存在与内部包含的 html 元素是无关的.

在完成标记化后, 标记信息会被发送给建树器, **来创建对应的 DOM 对象**, 而在创建完成后, 它会被加入到 DOM 树, 同时会被压入开放元素栈中.(`<p></p>`是开放元素, `<br/>`闭合元素)

再以上面那段为例:

- 接收到`html`标签, 变为 **Before Html** 状态, 创建一个 DOM 元素 **HTMLHtmlElement**, 添加到根对象, 并入栈

- 接收到`head`标签, 并创建**HTMLHeadElement**元素, 注意如果没有写 head 标签, 同样会自动生成.
- `body`标签同理, 进入`p`标签后, 接收到了字符, 会创建一个 **Text** 节点来保存
- 依次处理结束标记

### 解析 CSS

CSS 样式的来源主要有:

- **link 标签引用样式表**
- **style 标签**
- **内联样式**

实际上这三种来源都会被进行统一转化, 由渲染引擎收集并转化为一个结构化的对象 `StyleSheet`, 你可以通过`document.styleSheets`来查看它. 同时有一部分的 CSS 属性值并不能被直接使用, 还需要进行标准化, 最常见的就是`em`单位, 颜色取值(`red`->`#ff0000`)等

在进行统一与标准化后, 每个节点的具体样式信息就很容易计算了, 这一步主要包括两个规则, **继承** 与 **层叠**, 继承即是当一个元素没有自己的样式时, 会去继承父元素的可继承样式, 或者是浏览器内置的默认样式. 至于层叠规则, 这里就不做展开了, 因为我也还没完全搞懂层叠上下文...

有了继承规则与层叠规则后, 就能够对 DOM 节点进行具体样式计算

### 生成 布局树

在得到了 DOM 树 与 CSSOM 树 后, 接下来就可以开始附着合成得到布局树了, 大致流程很简单, 就是遍历 DOM 树节点添加到布局树, 并根据 CSSOM 树以及预置规则计算布局树节点的坐标位置.

> `display: none`的元素不会被添加到布局树, 但是`visibility: hidden`会, 也就要区分 DOM 树和布局树

> 我认为这一步是 **第一次回流** 发生的时间

布局树的计算属于 DFS, 从上到下从外到内的递归过程, 依次计算每个渲染对象的位置/尺寸.

### 图层树

> 这一块就是重中之重了, 也是我之前浅尝辄止的地方

在得到布局树后并不能立刻绘制页面, 因为可能存在着滚动条与 z-index 这些属性使得页面分层了, 所以渲染引擎还需要进行分层处理得到 **图层树(Layer Tree)**.

但并不是每一个节点都会拥有自己的图层, 当一个节点满足以下条件之一, 就会拥有自己的图层(即被提升到一个单独的合成层)

- 拥有[**层叠上下文属性**](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FGuide%2FCSS%2FUnderstanding_z_index%2FThe_stacking_context)
- 需要进行**剪裁**(`clip`)

上面这两种是显式的图层提升, 还有一种常常被忽略的隐式情况:

> **层叠等级低的节点被提升为单独的图层之后，那么所有层叠等级比它高的节点都会成为一个单独的图层**

这也是我对开头那个内存优化的问题的回答:

"当一个 z-index 属性值较低的元素被提升为了单独图层, 那么拥有更高的层叠水平的元素都会被提升为单独的图层, 有可能达到上千个, 这会大大增加内存压力甚至直接 **boom** 掉页面."

以上这个场景也被称为 **层爆炸**, 大量预期外的合成层在最终 **composite** 时会严重影响性能.

看到了一个比较简单直接的解决方式, **添加`z-index`来打破合成的排序, 避免渲染引擎创建不必要的合成层来提升渲染性能**. 其原理主要是干扰了隐式提升, 使得**其他元素不和合成层重叠**.

举例来说, 我们知道使用`translate3D`可以开启硬件加速, 原因也是一旦被提升到独立的合成层就会拥有自己**独立的绘图上下文**, 而合成层的位图(啥是位图后面会讲)是交由 GPU 合成的, 比 CPU 要更快. 这也是显式合成的优点, 其他优点还有如重绘时只会重绘该层, **不会导致整个页面重绘**.

(埋个坑, 这一块感觉还有点绕, 日后回来完善)

### 绘制列表

在得到图层树后, 渲染引擎就要开始绘制各个图层了, 但是要怎么绘制? 各个图层的先后顺序如何决定? 在这一步渲染引擎会将图层的绘制拆分成多个细碎的绘制指令, 然后将绘制指令按照一定顺序放入 **绘制列表**, 按照什么顺序呢? CSS 规范是这样规定的:

- **背景颜色**
- **背景图片**
- **边框**
- **子代**
- **轮廓**

### 图块与位图

在生成绘制列表后, 它会被提交合成线程, 而后合成线程开始绘制前还要考虑一个问题, 可视窗口就这么大, 但是页面可能超级长, 要一口气全绘制出来吗? 当然不, 性能就是前端的命啊, 合成线程在获得绘制列表后会首先根据当前可见范围附近的图块(通常是 **256\*256** / **512\*512** 的规格进行分块)来生成位图.

将图转化为位图的这一步操作称为 **栅格化(Raster)**, 图块是栅格化执行的最小单元, 渲染进程维护了一个**栅格化线程池**, 在其中进行图块的栅格化操作.

还有一点, 栅格化通常会使用 GPU(by GPU 进程)进行加速, 这样生成的位图会被保存在 GPU 内存中, 好处就在于主线程阻塞(大量 DOM 操作)时合成线程与 GPU 线程不会受到影响, 动画还可以继续 blingbling.

在 Chrome 底层还进行了一项优化, 由浏览器内存上传到 GPU 内存是比较慢的, 就算只绘制可见图块也会耗费一定时间, 因此它选择在首次合成时只采用一个较低分辨率的图片, 然后继续进行合成操作, 在正常内容绘制完毕后再替换掉当前图块.

### 显示内容

在栅格化完成后, 合成线程会告知主进程, 并由主进程将页面内容绘制到内存, 然后把这部分内存发送给显卡. 然后我们就能看到页面啦!

## 总结

重新梳理一下整个流程:

![project](http://47.98.159.95/my_blog/week10/4.jpg)

浏览器学问还是蛮多的..., 其实这篇文章还是省略了一些部分, 哈哈哈哈等我再厉害一点就回来把它们安排了.

## 参考文章

- [003: 说一说从输入 URL 到页面呈现发生了什么？——渲染过程篇](http://47.98.159.95/my_blog/browser-render/003.html#一、建图层树)

- [深入浅出浏览器渲染](https://www.jianshu.com/p/9c4e896f5b83)
- [浏览器渲染页面过程与页面优化](https://segmentfault.com/a/1190000010298038)

- [浏览器渲染流程&Composite（渲染层合并）简单总结](https://segmentfault.com/a/1190000014520786)
