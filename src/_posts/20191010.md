---
category: 前端-库
tags:
  - Axios
date: 2019-10-10
title: Axios的简单封装（配合Mock）
---

## 写在前面

- 如果还不知道 Axios 是啥，推荐先看一部分官方的[**GitHub**](https://github.com/axios/axios "axios-github-url")，它的 README 里很清晰的告诉了你它是干什么的，你要怎么使用它。

- 如果已经使用过，但还仅限于*axios.get(xxx...)*此类简单用法，而没有接触过拦截器等，建议阅读官方指南的大部分，或者如果你跟我一样英语看多了脑壳疼，可以看一下这一份[文档](https://www.kancloud.cn/yunye/axios/234845,'axios-doc-cn')（但还是建议多看看英语，我现在正在为六级发愁呢）

## Axios 封装-Get 与 Post

### Mock 与 Axios-Mock-Adapter

- [**Axios-Mock-Adapter**](https://github.com/ctimmerm/axios-mock-adapter "AMA-github")是一个基于 axios 的模拟调试器，你可以使用它来模拟并配置一个接口，然后使用 axios 向这个接口请求数据，这样你不仅不需要考虑跨域，甚至不需要考虑有没有网络了(っ ´Ι`)っ，它的使用可以先参考官方的 README，我这里只用到了一部分。
  **需要和 Mock 配合使用哟**

### mock 一个接口

- 这个 Demo 我是运行在 Vue-Cli 3.x 上的，项目目录可能和 2.X 有一些不同，如果有目录结构方面的疑问请参考[Vue-Cli 3.x 文档](https://cli.vuejs.org/zh/guide/ "vuecli3.x-doc")

- 首先在 **src** 目录下新建一个**mock**文件夹，并在其中新建*mock.js*以及*index.js*，对了，记得 npm install 它们哟

- _mock.js_ 的书写

  > 首先引入这两个模块，并直接在*export*中进行配置

  ```JavaScript
  import axios from "axios";
  import MockAdapter from "axios-mock-adapter";

  export default{
    bootstrap(){
      let mock = new MockAdapter(axios);
    }
  }
  ```

  我们后续的配置都写在 bootstrap()方法中，似乎现在已经不用再这样，而是可以直接写在*export*中了，但我总觉得这样更舒服~( ‵▽′)ψ

  这个调试器会响应 axios 对指定 url 发起的指定类型的请求，比如对"xxx.cn/mockget"这个特定地址发起的 携带着 params 参数的**get**请求，我们可以这么写：

  ```JavaScript
  //mock = new MockAdapter(axios);
  // axios.defaults.baseURL = "",后文会提这个
    mock.onGet('/mockget').reply(config =>{
      //在这里配置
      let params = config.params;
    })
  ```

  可能有人会像我之前一样感到疑惑，config 是哪里来的？实际上它就是这次 axios 请求的配置项，包含 url、method、data、headers 等等，我们在这里能做的有限，于是就把前面传进去的参数再返回出来来测试（有点呆，但还挺好玩(●ˇ∀ˇ●)）

  在这里我们让这个接口返回一个 Promise 对象（然后在页面里再调用*then()*和*catch()*），所以整个 **onGet()** 方法我们这样写

  ```JavaScript
  mock.onGet("/mockget").reply(config => {
        let params = config.params;
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve([200, params]);
          }, 500);
        });
      });
  ```

  用 setTimeout()模拟一个请求后的延时回应，在这里 resolve([200,params])指的是本次请求状态码 200，数据为 params，总之格式应当是['status code',{ }]

    <details>

    <summary>*mock.js* 完整代码：（含注释）</summary>

  ```JavaScript
  /* eslint-disable */

  import axios from "axios";
  import MockAdapter from "axios-mock-adapter";

  export default {
    bootstrap() {//配置mock代理
      let mock = new MockAdapter(axios);
      //mock会拦截 向对应地址发起的 特定请求类型
      mock.onGet("/mockget").reply(config => {
        let params = config.params;
        return new Promise((resolve, reject) => {
          //返回一个promise对象，我们可以在接受这个对象的地方调用then()方法和catch()方法
          setTimeout(() => {
            // resolve([404, { params: params }]);
            //正常情况下不会只返回先前调用时传递的参数，这里只是模拟一下
            resolve([200, params]);
          }, 500);
        });
      });
      mock.onPost("/mockpost").reply(config => {
        console.log(config);
        console.log(JSON.parse(config.data));
        let params = JSON.parse(config.data).params;
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve([200, params]);
          }, 500);
        });
      });
    }
  };

  ```

    </details>

- *index.js*书写  
  事实上这个文件不是必要的，它只是把*mock.js*的全引进来然后再导出去，好处就是在 main.js 中你可以直接用目录名称引入即 ...from './mock'

  ```JavaScript
  import mock from "./mock";
  export default mock;
  ```

- 到这里接口的大致工作就准备的差不多了，接下来我们准备简易的封装 axios（get 请求、post 请求）

### 先封装个 get 和 post 请求尝尝鲜

- 在*src*下目录下新建一个*request*文件夹，而后在其中新建*api.js*，_http.js_，我们会在*http.js*中封装 axios 的**get**、**post**请求以及**请求拦截器**、**响应拦截器**。而在*api.js*中，我们会直接把调用（我们自己封装的）get 和 post 请求的过程封装在两个方法里，这样后面我们直接在页面文件中(_.vue_)调用这两个方法。

- _http.js_  
  首先我们还是引入 axios
  (在一些封装过程中还使用了 qs 模块，我这里直接用 JSON.parse()方法代替一下)
  接着对 axios 的默认配置进行一些 diy

  ```JavaScript
  import axios from "axios";
  //设置基准URL
  axios.defaults.baseURL = "";
  //设置超时时间
  axios.defaults.timeout = 10000;
  //为Post请求设置请求头
  axios.defaults.headers["Content-Type"] =
  "application/x-www-form-urlencoded;charset=UTF-8";
  ```

- 封装 get 请求：

```JavaScript
  export function get(url, params) {
  return new Promise((resolve, reject) => {
    axios
      .get(url, {
        params: params
      })
      .then(res => {
        resolve(res);
      })
      .catch(err => {
        console.error(err);
        reject(err);
      });
  });
}
```

（其实我感觉光这不能叫封装...，请求拦截器和响应拦截器才更有封装的味道：把它变成最适合自己的）

- Post 请求也是类似的，只是可能需要对参数做一些处理，如  
  _qs.stringify(params)_

## Axios 封装-请求与响应拦截器

- 这应该是大部分封装主要着手的地方，可以根据自己的需要对请求/响应进行拦截，进行一些处理后再返回（当然你要是比较狠也可以禁止返回）

  关于拦截器的触发时机，请看这张图

![拦截器](https://ftp.bmp.ovh/imgs/2019/10/ef6855910332a664.png)

- 请求拦截器  
  请求拦截器有很多作用（虽然现在的我还说不大上来？），我使用过的有用来替代**节流**与**防抖** 防止一段时间内的重复请求，和用来改变请求的参数等。

  ```JavaScript

  const cancel = false;
  let cancelToken = axios.CancelToken;

    axios.interceptors.request.use(
  config => {
    //这里的config和mock的onGet/onPost方法中的config是一样的，
    console.log(config);
    config.cancelToken = new cancelToken(function executor(c) {
      if (cancel) {
        c();
      }
    });
    return Promise.resolve(config);
  },
  err => {
    console.error(err);
    return Promise.reject(config);
    }
  )
  ```

  有一个需要注意的地方，当我们进行了判断并决定**取消本次请求**时，需要使用*axios.CancelToken*（它是一个构造函数），并且为**config**的**cancelToken**项配置

  ```JavaScript
  config.cancelToken = new cancelToken(function executor (c) {
      if (cancel) {
        c();
      }
    });
  ```

  如果难以理解，只需要知道, **c()** 是 cancelToken()内生成的取消函数，如果我们调用了它(就像上面，那么本次请求就会被拦截)

- 响应拦截器
  如果这个请求侥幸过了上面一关，那也不意味着它能正常的被接收到。还有响应拦截器等着它呢。响应拦截器同样用处多多，你可以在这里把数据给处理了，比如根据用户权限返回不同部分的数据或是其他，甚至还可以直接把数据全部拦截掉。（用户：mmp）  
  但实际上大部分操作是在响应失败（如状态码 404 的等）的情况下处理的，比如我们会根据不同的报错状态码进行不同的提示。

```JavaScript
axios.interceptors.response.use(
  response => {
    return Promise.resolve(response);
  },
  err => {
    console.log(err.response.status);
    if (err.response) {
      switch (err.response.status) {
        case 401: {
          console.log("错误代码401");
        }
        case 404: {
          console.log("错误代码404");
        }
        default:
          console.log("失败咯弟弟！");
      }
    }
  }
);
```

在上面的代码里，我们规定了错误代码 401 和 404 的不同提示。为了验证是否可行，我们把前面 mock 出来的接口的返回状态码改为 404 进行尝试，在控制台中打印的结果如图

![拦截](https://i.bmp.ovh/imgs/2019/10/63f8910fac8930ec.png)

<details>

<summary>完整的*http.js*（含有注释）</summary>

```JavaScript
/* eslint-disable */
import qs from "qs";
import axios from "axios";

axios.defaults.baseURL = "";
axios.defaults.timeout = 10000;
axios.defaults.headers["Content-Type"] =
  "application/x-www-form-urlencoded;charset=UTF-8";

const cancel = false;
let cancelToken = axios.CancelToken;

//请求拦截器 request
axios.interceptors.request.use(
  config => {
    //这里的config和mock的onGet/onPost方法中的config是一样的，
    console.log(config);
    // console.log(qs.stringify({ key1: "post-val1", key2: "post-val2" }));
    config.cancelToken = new cancelToken(function executor(c) {
      if (cancel) {
        c();
      }
    });
    return Promise.resolve(config);
  },
  err => {
    console.error(err);
    return Promise.reject(config);
  }
);

//响应拦截器
axios.interceptors.response.use(
  response => {
    //responese就是得到的回应啦
    //在成功部分一般不会进行什么操作？
    //一般在下面的错误部分进行操作 如根据返回的代码进行提示等等
    // console.log(response);
    return Promise.resolve(response);
  },
  err => {
    console.log(err.response.status);
    if (err.response) {
      switch (err.response.status) {
        case 401: {
          console.log("错误代码401");
        }
        case 404: {
          console.log("错误代码404");
        }
        default:
          console.log("失败咯弟弟！");
      }
    }
  }
);

export function get(url, params) {
  return new Promise((resolve, reject) => {
    axios
      .get(url, {
        params: params
      })
      .then(res => {
        resolve(res);
      })
      .catch(err => {
        console.error(err);
        reject(err);
      });
  });
}

export function post(url, params) {
  return new Promise((resolve, reject) => {
    // axios.post(url, qs.stringify(params));
    console.log(qs.stringify(params));
    axios
      .post(url, params)
      .then(res => {
        resolve(res);
      })
      .catch(err => {
        console.error(err);
        reject(err);
      });
  });
}

```

 </details>

- _api.js_
  比较简单，不多说咯

```JavaScript
import { get, post } from "./http";

export const getTest = params => get("/mockget", params);
export const postTest = params => post("/mockpost", params);
```

## Axios 封装-使用

- 我们直接在页面中调用这个方法

```JavaScript
getData() {
      getTest({
        key: "get-val"
      })
        .then(res => {
          //可以加一下对res不为空的验证
          console.log(res)
        })
        .catch(err => {
          console.log(err)
        })
      postTest({ key1: "post-val1", key2: "post-val2" })
        .then(res => {
          console.log(res)
        })
        .catch(err => {
          console.log(err)
        })
    }
```

- 控制台打印回应的结果：

![res](https://i.bmp.ovh/imgs/2019/10/f8f79b322d42f57d.png)

## Tips

- 在main.js中，我们需要对mock进行额外的一步处理

```JavaScript
import Mock from "./mock";
Mock.bootstrap();
```

- 源码已经放在[GitHub](https://github.com/linbudu599/Axiospkg)啦 今后也会不断完善这个现在十分简陋的axios封装的~
