<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>关于useSelector的一些学习 | 林不渡</title>
    <meta name="description" content="Linbudu&#39;s Blog">
    <link rel="icon" href=".">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="preload" href="/assets/css/0.styles.98f786a8.css" as="style"><link rel="preload" href="/assets/js/app.f1c0817c.js" as="script"><link rel="preload" href="/assets/js/6.b9eb77b4.js" as="script"><link rel="preload" href="/assets/js/14.5da4ef97.js" as="script"><link rel="prefetch" href="/assets/js/1.b5e212fc.js"><link rel="prefetch" href="/assets/js/10.e6312c93.js"><link rel="prefetch" href="/assets/js/11.cb9748b4.js"><link rel="prefetch" href="/assets/js/12.febcf5ca.js"><link rel="prefetch" href="/assets/js/13.b0bf2c25.js"><link rel="prefetch" href="/assets/js/15.53b16531.js"><link rel="prefetch" href="/assets/js/16.cf70793c.js"><link rel="prefetch" href="/assets/js/17.259c6548.js"><link rel="prefetch" href="/assets/js/18.0357c632.js"><link rel="prefetch" href="/assets/js/3.a618da4f.js"><link rel="prefetch" href="/assets/js/4.ecf13a8e.js"><link rel="prefetch" href="/assets/js/5.b4ee5db2.js"><link rel="prefetch" href="/assets/js/7.caec1cbd.js"><link rel="prefetch" href="/assets/js/8.07ed1f0e.js"><link rel="prefetch" href="/assets/js/9.77a6d022.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98f786a8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-meteorlxy"><header class="header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(https://linbudu.top/assets/img/jp-valery-734900-unsplash.jpg);" data-v-0be91240><div data-v-740e207b data-v-0be91240><nav class="navbar" data-v-740e207b><div class="container" data-v-740e207b><a href="/" class="router-link-active" data-v-740e207b><span class="navbar-site-name" data-v-740e207b>
          林不渡
        </span></a> <div class="navbar-toggler" data-v-740e207b><svg class="icon" style="font-size:1.2em;" data-v-740e207b data-v-740e207b><title data-v-740e207b data-v-740e207b>menu</title><use xlink:href="#icon-menu" data-v-740e207b data-v-740e207b></use></svg></div> <div class="navbar-links" data-v-740e207b><a href="/" class="navbar-link" data-v-740e207b>
            主页
          </a><a href="/posts/" class="navbar-link router-link-active" data-v-740e207b>
            往期博文
          </a><a href="/about/" class="navbar-link" data-v-740e207b>
            关于我
          </a></div></div></nav> <div class="navbar-holder" style="display:none;" data-v-740e207b></div></div> <div class="banner" data-v-98d6aa8c data-v-0be91240 data-v-0be91240><div class="container" data-v-98d6aa8c><div class="center" data-v-98d6aa8c><h1 data-v-98d6aa8c data-v-0be91240>
          关于useSelector的一些学习
        </h1></div></div></div></header> <div class="container clearfix show-aside" data-v-6e91a59a data-v-6e91a59a><main class="main" data-v-6e91a59a><div class="post" data-v-6e91a59a data-v-6e91a59a><section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2020-02-20
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : 2020-02-21
    </span></section> <section class="post-links" data-v-4e23451f><a href="/posts/2020/01/28/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91.html" class="post-link" data-v-4e23451f>
      上一篇 : 科 学 上 网：请自由的上网冲浪
    </a> <!----></section></section> <article class="main-div"><div class="post-content content content__default"><h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2> <p>又懒又忙的我会突然为<code>useSelector</code>整理一篇博文，是因为之前的我使用它，就是直接用而已，完全不考虑它替我们做了什么，和 connect 比起来又有什么好处，以及它是如何发扬 Hooks 的哲学的，直到前几天偶然看见一篇文章，又去研究了下官方文档，才发现好像我之前的使用过于浅显，我很不喜欢这种感觉，正好也将近一个月没写过博客了，于是就趁此机会做一下记录。</p> <p>这篇文章大部分思路和示例来自于知乎作者<a href="https://www.zhihu.com/people/otakustay" target="_blank" rel="noopener noreferrer">张立理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，是和贺师俊、杨健等等前端领域同一批次的大佬。也正是作者的讲解让我对这个 api 产生了兴趣。</p> <h2 id="react-redux-与-reselect"><a href="#react-redux-与-reselect" aria-hidden="true" class="header-anchor">#</a> React-Redux 与 Reselect</h2> <p>其实早在<code>React-Redux@7</code>发布之前，就已经能够见到这样一种写法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// store/selector.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">dataSelector</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    data<span class="token punctuation">:</span> <span class="token comment">// ... 假装这里有很复杂的逻辑</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// page/index.js</span>
<span class="token keyword">const</span> <span class="token function-variable function">mapStateToProps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">dataSelector</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// ... 然后connect</span>
</code></pre></div><p>这种写法的好处是很明显的，页面中不会再出现又臭又长的 state 提取/转换逻辑，但是其实这并没有改变实质上的问题：</p> <p>如果组件发生了更新，那么就要重新调用<code>dataSelector()</code>进行计算，如果这里的转换逻辑过于复杂，那么性能势必会受到影响。</p> <p>因此 <a href="https://github.com/reduxjs/reselect" target="_blank" rel="noopener noreferrer">Reselect<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 应运而生，从它的自我介绍就能很容易知道它诞生是为了解决什么：</p> <blockquote><p>Simple “selector” library for Redux (and others) inspired by getters in NuclearJS, subscriptions in re-frame and this proposal from speedskater.</p> <p>对于 Reselect 这个库我只用过一两次，只用到了最为主要的那个 API，因此以下介绍可能有失偏颇。</p></blockquote> <p>这是一个最基本的使用例子：</p> <p><strong><code>createSelector(...inputSelectors | [inputSelectors], resultFunc)</code></strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createSelector <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;reselect&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">selectorA</span> <span class="token operator">=</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>account<span class="token punctuation">.</span>username<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">selectorB</span> <span class="token operator">=</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>account<span class="token punctuation">.</span>info<span class="token punctuation">;</span>
<span class="token keyword">const</span> selectSomeData <span class="token operator">=</span> <span class="token function">createSelector</span><span class="token punctuation">(</span>
  <span class="token comment">// 不一定要数组哈，也可以分开传</span>
  <span class="token punctuation">[</span>selectorA<span class="token punctuation">,</span> selectorB<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">username<span class="token punctuation">,</span> info</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>username<span class="token punctuation">,</span> infoDeatil<span class="token punctuation">:</span> info<span class="token punctuation">[</span>username<span class="token punctuation">.</span>info<span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 一个copy的例子</span>
<span class="token keyword">const</span> <span class="token function-variable function">getVisibilityFilter</span> <span class="token operator">=</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>visibilityFilter<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">getTodos</span> <span class="token operator">=</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>todos<span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> getVisibleTodos <span class="token operator">=</span> <span class="token function">createSelector</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>getVisibilityFilter<span class="token punctuation">,</span> getTodos<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">visibilityFilter<span class="token punctuation">,</span> todos</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>visibilityFilter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">&quot;SHOW_ALL&quot;</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> todos<span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token string">&quot;SHOW_COMPLETED&quot;</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> todos<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">t</span> <span class="token operator">=&gt;</span> t<span class="token punctuation">.</span>completed<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token string">&quot;SHOW_ACTIVE&quot;</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> todos<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">t</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span>completed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个 API 接收选择器（<code>input-selectors</code>）和变换函数作为参数，选择器返回的值会被作为变换函数的入参，你可以在这里进行更细的筛选。
如果<code>input-selectors</code>的值不变，即变换函数的入参不变，说明最后的变换结果也不会变，那么<code>reselect</code>会直接返回缓存起来的值。</p> <p><code>reselect</code>的大致思路就是这样，它良好（不敢说很好，因为没怎么用）的解决了组件更新时的计算开销，如果变动的不是或不会影响<code>store</code>中的数据，那么就不会重新调用选择器进行计算。</p> <p><s>也许是因为这个思路是大势所趋，<code>React-Redux@7</code>推出了<code>useSelector</code>这个方法。</s></p> <p>为什么要划掉呢，因为这个方法和<code>reselect</code>其实关联甚少，最重要的是它的缓存功能太弱了（参看下文），试问，谁不想享受<code>useSelector</code>的便利同时让缓存机制保护我们的应用呢？</p> <h2 id="useselector"><a href="#useselector" aria-hidden="true" class="header-anchor">#</a> useSelector</h2> <p>这个 api 的使用方式没有什么要讲的，我扔个例子你们就看懂了。</p> <p><code>const result : any = useSelector(selector : Function, equalityFn? : Function)</code></p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token comment">// 这里的getIn是Immutable.Js的，和这个api无关哈。</span>
<span class="token keyword">const</span> data<span class="token punctuation">:</span> IRank <span class="token operator">=</span> <span class="token function">useSelector</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">:</span> IGlobalState</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  rankList<span class="token punctuation">:</span> state<span class="token punctuation">.</span><span class="token function">getIn</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;rank&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;rankList&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  loading<span class="token punctuation">:</span> state<span class="token punctuation">.</span><span class="token function">getIn</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;rank&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;loading&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> rankList<span class="token punctuation">,</span> loading <span class="token punctuation">}</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>
</code></pre></div><p>和<code>mapStateToProps</code>很像吧？的确是这样，它同样也会订阅 store，并且在你每分发一个 action 就会执行一次。</p> <blockquote><p>你可以在一个函数组件中多次调用 useSelector()。每一个 useSelector() 的调用都会对 Redux 的 store 创建的一个独立的 订阅(subscription)。由于 Redux v7 的 批量更新(update batching) 行为，对于一个组件来说，如果一个 分发后(dispatched) 的 action 导致组件内部的多个 useSelector() 产生了新值，那么仅仅会触发一次重渲染。</p></blockquote> <p>当你分发 action 后，它会将上一次调用的结果和本次调用的结果进行比较（通过严格比较===，connect 使用的是浅比较），如果不一样，组件才会被强制重渲染。</p> <blockquote><p>浅比较并不是指 ==。严格比较 === 对应的是 疏松比较 ==，与 浅比较 对应的是 深比较。
深比较会递归进行浅比较，需要两个对象的属性都相等才会返回 true。同时深比较不会考虑这两个对象是不是同一个对象的引用。后面会展开讲。</p></blockquote> <blockquote><p>我们可以多次调用它，每一个调用都会创建一个独立的订阅。由于 Redux v7 的 批量更新(update batching) 行为，对于一个组件来说，如果一个 分发后(dispatched) 的 action 导致组件内部的多个 useSelector() 产生了新值，那么仅仅会触发一次重渲染。</p></blockquote> <p>其实就是官方为我们提供了一个比 connect 更优雅的方式来组织代码，但是我们最关心的缓存问题却并没有解决。
它提供的缓存能力同样是不那么有效的，严格比较与浅比较，你懂的。</p> <p>但是如果追求接近完美的缓存，就有点过于苛求 react-redux 了，缓存模型应当是研发人员的重要任务，但是<code>Apollo</code>的缓存我感觉就挺好~</p> <p>话说回来，如果对缓存的需要不可忽视，那么我们需要再把<code>Reselect</code>请回来，用法不变，还是用<code>createSelector</code>把选择器包起来，多了一步传给<code>useSelector</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createSelector <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;reselect&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useSelector <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react-redux&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> selectUserDisplay <span class="token operator">=</span> <span class="token function">createSelector</span><span class="token punctuation">(</span>
  <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>currentUser<span class="token punctuation">,</span>
  <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>entities<span class="token punctuation">.</span>jobs<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">user<span class="token punctuation">,</span> jobs</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>user<span class="token punctuation">,</span> job<span class="token punctuation">:</span> jobs<span class="token punctuation">[</span>user<span class="token punctuation">.</span>job<span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 在组件里</span>
<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token function">useSelector</span><span class="token punctuation">(</span>selectUserDisplay<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面和以下示例来自于张老师的文章：</p> <blockquote><p>当你需要根据组件自己的 state 或 props 去访问 store 的时候，这么实现（指上面的例子）显然是不行的，所以你需要 useCallback：</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useCallback <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createSelector <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;reselect&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useSelector <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react-redux&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 下面全部在组件里</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> id <span class="token punctuation">}</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
<span class="token keyword">const</span> selectUserDisplay <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>
  <span class="token function">createSelector</span><span class="token punctuation">(</span>
    <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>users<span class="token punctuation">,</span>
    <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>entities<span class="token punctuation">.</span>jobs<span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token parameter">users<span class="token punctuation">,</span> jobs</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> job<span class="token punctuation">,</span> <span class="token operator">...</span>user <span class="token punctuation">}</span> <span class="token operator">=</span> users<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>user<span class="token punctuation">,</span> job<span class="token punctuation">:</span> jobs<span class="token punctuation">[</span>job<span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>id<span class="token punctuation">]</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token function">useSelector</span><span class="token punctuation">(</span>selectUserDisplay<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>不同于普通的纯函数，createSelector 是有开销的，包括组装函数的时间开销，以及开辟一个内部缓存的空间开销。useCallback 虽然能稳定返回的函数，但并不减少 createSelector 的调用次数，只是一部分调用所返回的结果被直接丢弃，等着 GC 回收。但是，GC 是性能的大敌，从 Immutable 到 useCallback 产生的碎片，这是整个 React 当前的性能模型所未能解决的问题。</p></blockquote> <p>其实</p> <p>作者提供了他认为最优的方案：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useMemo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useSelector <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react-redux&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 组件里</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> id <span class="token punctuation">}</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
<span class="token keyword">const</span> users <span class="token operator">=</span> <span class="token function">useSelector</span><span class="token punctuation">(</span><span class="token parameter">s</span> <span class="token operator">=&gt;</span> s<span class="token punctuation">.</span>entities<span class="token punctuation">.</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> jobs <span class="token operator">=</span> <span class="token function">useSelector</span><span class="token punctuation">(</span><span class="token parameter">s</span> <span class="token operator">=&gt;</span> s<span class="token punctuation">.</span>entities<span class="token punctuation">.</span>jobs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> userDisplay <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> job<span class="token punctuation">,</span> <span class="token operator">...</span>user <span class="token punctuation">}</span> <span class="token operator">=</span> users<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>user<span class="token punctuation">,</span> job<span class="token punctuation">:</span> jobs<span class="token punctuation">[</span>job<span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>id<span class="token punctuation">,</span> users<span class="token punctuation">,</span> jobs<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>（其实我也没能想到 useMemo 还能这么用。）</p> <p>这种思路使得细粒度筛选 store 和良好缓存能力很好的共存了，而且也能使用组件内部的状态/属性来参与筛选。我愿称之为妙！</p> <p>同时注意，你可以会发现我们还可以传入另外一个参数，react-redux 提供的<code>shallowEqual()</code>，或是 Immutable.js/Lodash 提供的方法。这个参数会作为比较两次调用结果的计算函数。</p> <h2 id="场景"><a href="#场景" aria-hidden="true" class="header-anchor">#</a> 场景</h2> <p>实际上现在我们有两种方案，当组件单纯连接到 store，并且提取数据不需要使用组件内部状态，那么 createSelector 会是不错的选择（注意，createSelector 本身也是有开销的）。当提取数据需要更细粒度，并且过程依赖组件属性/状态，那么像这种 useMemo 的搭配会更好。</p> <h2 id="彩蛋"><a href="#彩蛋" aria-hidden="true" class="header-anchor">#</a> 彩蛋</h2> <p>react-redux@7 并不是只提供了这一个 hooks，下面会简单介绍一下我使用/了解过的 hooks。</p> <h3 id="usedispatch"><a href="#usedispatch" aria-hidden="true" class="header-anchor">#</a> useDispatch</h3> <p>如果说 useSelector 是为了替代 mapStateToProps，那么 useDispatch 就是为了替代 mapDispatchToProps，这两个一起使用以后，connect 就可以正式退休了。</p> <p>我个人理解，useDispatch 实际上就是返回了之前 mapDispatchToProps 的入参中的 diapatch 引用，使得现在可以直接在组件内部 dispatch 一个 action，但组件的属性中不需要有 dispatch。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useDispatch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react-redux&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">CounterComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> value <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dispatch <span class="token operator">=</span> <span class="token function">useDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">&quot;increment-counter&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        Increment counter
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>注意，如果你将一个内部调用了此类 dispatch 的函数传给子组件，最好把它用<code>useCallback</code>包裹起来，以避免不必要的重渲染。</p> <h3 id="usestore"><a href="#usestore" aria-hidden="true" class="header-anchor">#</a> useStore</h3> <p>通过这个 API，你现在可以直接访问到 Redux 的根 Store 了，一个比较可能用到这个 api 的场景就是在替换 store 的 reducer，比如 MPA 应用做热更新。</p> <h2 id="浅比较和深比较"><a href="#浅比较和深比较" aria-hidden="true" class="header-anchor">#</a> 浅比较和深比较</h2> <p>看了一下 React-Redux 提供的<code>ShallowEuqal</code>API 的源码，和 React 内部<code>shouldComponentUpdate</code>生命周期里的<code>ShallowEuqal</code>实现思路几乎一样，代码也差不多，这里贴一下 React 中的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> hasOwn <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>hasOwnProperty<span class="token punctuation">;</span>
<span class="token comment">// 实际上是Object.is()方法的补全</span>
<span class="token keyword">function</span> <span class="token function">is</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理+0===-0 true</span>
    <span class="token keyword">return</span> x <span class="token operator">!==</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">!==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token number">1</span> <span class="token operator">/</span> x <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">/</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理NaN===NaN false</span>
    <span class="token keyword">return</span> x <span class="token operator">!==</span> x <span class="token operator">&amp;&amp;</span> y <span class="token operator">!==</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">shallowEqual</span><span class="token punctuation">(</span><span class="token parameter">objA<span class="token punctuation">,</span> objB</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 对基本数据类型比较</span>
  <span class="token comment">// 过滤掉均为基本类型的情况</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">,</span> objB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token comment">// 过滤掉这两种情况</span>
  <span class="token comment">// 只有一方是对象</span>
  <span class="token comment">// 有null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> objA <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span>
    objA <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span>
    <span class="token keyword">typeof</span> objB <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span>
    objB <span class="token operator">===</span> <span class="token keyword">null</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> keysA <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objA<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> keysB <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objB<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>keysA<span class="token punctuation">.</span>length <span class="token operator">!==</span> keysB<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keysA<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>objB<span class="token punctuation">,</span> keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">[</span>keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> objB<span class="token punctuation">[</span>keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，浅比较实际上只比较了两个对象的 key 以及为基本类型的 value，如果存在嵌套对象就莫的法子了。
而深比较则是在浅比较的基础上对两个对象的子对象进行递归遍历，不去管子对象的引用，而是确保其值相同。</p> <h2 id="参考文章"><a href="#参考文章" aria-hidden="true" class="header-anchor">#</a> 参考文章</h2> <ul><li><a href="https://www.zhihu.com/question/332090851/answer/730617297" target="_blank" rel="noopener noreferrer">如何看待 react-redux@7 的 useSelector API？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.imweb.io/topic/598973c2c72aa8db35d2e291" target="_blank" rel="noopener noreferrer">IMWeb 你真的了解浅比较么？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://react-china.org/t/topic/34076" target="_blank" rel="noopener noreferrer">React-Redux 官方 Hooks 文档说明<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></article> <section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2020-02-20
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : 2020-02-21
    </span></section> <section class="post-links" data-v-4e23451f><a href="/posts/2020/01/28/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91.html" class="post-link" data-v-4e23451f>
      上一篇 : 科 学 上 网：请自由的上网冲浪
    </a> <!----></section></section> <!----></div></main> <aside class="aside" data-v-6e91a59a><div class="info-card main-div" data-v-23d90c50 data-v-6e91a59a><div class="info-card-header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(https://linbudu.top/assets/img/thomas-tixtaaz-119883-unsplash.jpg);" data-v-23d90c50><img src="https://linbudu.top/assets/img/icon1.png" alt="林不渡" class="info-avatar" data-v-23d90c50></div> <div class="info-card-body" data-v-23d90c50><section class="info-nickname" data-v-23d90c50>
      林不渡
    </section> <section class="info-desc" data-v-23d90c50>未来的不可知，是前进的原动力</section> <section class="info-contact" data-v-23d90c50><!----> <!----> <section data-v-23d90c50><a href="mailto:linbudu@qq.com" title="linbudu@qq.com" data-v-23d90c50 data-v-23d90c50><svg class="icon" style="font-size:1em;" data-v-23d90c50 data-v-23d90c50><title data-v-23d90c50 data-v-23d90c50>linbudu@qq.com</title><use xlink:href="#icon-email" data-v-23d90c50 data-v-23d90c50></use></svg><span class="info-text" data-v-23d90c50 data-v-23d90c50>
          linbudu@qq.com
        </span></a></section></section></div> <div class="info-card-footer" data-v-23d90c50><section class="info-sns clearfix" data-v-23d90c50><a href="https://github.com/linbudu599" target="_blank" class="sns-link" data-v-23d90c50><span title="GitHub: Linbudu" class="sns-icon" data-v-23d90c50 data-v-23d90c50><svg class="icon" style="font-size:1.5em;" data-v-23d90c50 data-v-23d90c50><title data-v-23d90c50 data-v-23d90c50>GitHub: Linbudu</title><use xlink:href="#icon-github" data-v-23d90c50 data-v-23d90c50></use></svg></span></a></section></div></div> <div class="post-nav-card main-div" style="position:relative;top:0;width:0px;" data-v-6e91a59a><div class="post-nav-contents"><svg class="icon"><title>book</title><use xlink:href="#icon-book"></use></svg> <span>文章目录</span> <div class="post-nav-toc"><ul><li><a href="/posts/2020/02/20/%E5%85%B3%E4%BA%8Euseselector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html#前言">前言</a></li><li><a href="/posts/2020/02/20/%E5%85%B3%E4%BA%8Euseselector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html#react-redux-与-reselect">React-Redux 与 Reselect</a></li><li><a href="/posts/2020/02/20/%E5%85%B3%E4%BA%8Euseselector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html#useselector">useSelector</a></li><li><a href="/posts/2020/02/20/%E5%85%B3%E4%BA%8Euseselector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html#场景">场景</a></li><li><a href="/posts/2020/02/20/%E5%85%B3%E4%BA%8Euseselector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html#彩蛋">彩蛋</a><ul><li><a href="/posts/2020/02/20/%E5%85%B3%E4%BA%8Euseselector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html#usedispatch">useDispatch</a></li><li><a href="/posts/2020/02/20/%E5%85%B3%E4%BA%8Euseselector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html#usestore">useStore</a></li></ul></li><li><a href="/posts/2020/02/20/%E5%85%B3%E4%BA%8Euseselector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html#浅比较和深比较">浅比较和深比较</a></li><li><a href="/posts/2020/02/20/%E5%85%B3%E4%BA%8Euseselector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html#参考文章">参考文章</a></li></ul></div></div> <!----></div></aside></div> <footer class="footer" data-v-f018ab8c><p class="footer-sns-links" data-v-f018ab8c><a href="https://github.com/linbudu599" target="_blank" class="sns-link" data-v-f018ab8c><span title="GitHub: Linbudu" class="sns-icon" data-v-f018ab8c data-v-f018ab8c><svg class="icon" style="font-size:25px;" data-v-f018ab8c data-v-f018ab8c><title data-v-f018ab8c data-v-f018ab8c>GitHub: Linbudu</title><use xlink:href="#icon-github" data-v-f018ab8c data-v-f018ab8c></use></svg></span></a></p> <p class="footer-text" data-v-f018ab8c><span data-v-f018ab8c>Powered by </span> <a href="https://github.com/vuejs/vuepress" target="_blank" data-v-f018ab8c>
      VuePress
    </a> <span data-v-f018ab8c> | </span> <a href="https://github.com/meteorlxy/vuepress-theme-meteorlxy" target="_blank" data-v-f018ab8c>
        meteorlxy
      </a></p> <p class="footer-text" data-v-f018ab8c>Copyright 2019-present <a href="https://github.com/linbudu599" target="_blank">不渡</a> | MIT License</p></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.f1c0817c.js" defer></script><script src="/assets/js/6.b9eb77b4.js" defer></script><script src="/assets/js/14.5da4ef97.js" defer></script>
  </body>
</html>
